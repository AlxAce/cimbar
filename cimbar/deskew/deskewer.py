from math import sqrt

import cv2
import numpy

from cimbar.deskew.scanner import CimbarScanner


ANCHOR_SIZE = 30
ED_DIST = 4


def correct_perspective(img, target_size, input_pts, output_pts):
    transformer, _ = cv2.findHomography(numpy.float32(input_pts), numpy.float32(output_pts))
    return cv2.warpPerspective(img, transformer, target_size)


def _naive_undistort(img, distortion_factor):
    '''
    distortion factor calculated by _get_distortion_factor()
    '''
    height, width = img.shape[:2]
    print('***')
    print(f'{height},{width}, ... {distortion_factor}')

    distCoeff = numpy.zeros((4,1),numpy.float64)
    distCoeff[0,0] = distortion_factor;
    distCoeff[1,0] = 0.0;
    distCoeff[2,0] = 0.0;
    distCoeff[3,0] = 0.0;

    cam = numpy.eye(3, dtype=numpy.float32)
    cam[0,2] = width / 2
    cam[1,2] = height / 2
    cam[0,0] = 1000.
    cam[1,1] = 1000.

    return cv2.undistort(img, cam, distCoeff)


def distance(a, b):
    return sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2)


def _edge_to_anchor_ratio(size, anchor_size):
    # target_ratio = 0.026970954356846474  # can precompute the answer if we want to
    o0 = (anchor_size, anchor_size)
    o4 = (size // 2, ED_DIST)   # 4  = edge distance
    o1 = (size-anchor_size, anchor_size)  # 994 = (size-30)
    omid = (size // 2, anchor_size)  # 512 == (size // 2)
    return distance(o4, omid) / distance(o0, o1)


def _get_distortion_factor(align, ce, target_ratio):
    '''
    distortion_factor is generated by distance from the target_ratio.
    The expected calculation is in _edge_to_anchor_ratio()
    '''
    eparams = [
        (ce.edges[0], ce.top_mid, align.top_left, align.top_right),
        (ce.edges[1], ce.right_mid, align.top_right, align.bottom_right),
        (ce.edges[2], ce.bottom_mid, align.bottom_right, align.bottom_left),
        (ce.edges[3], ce.left_mid, align.bottom_left, align.top_left),
    ]

    max_ratio = 0
    for edj, line_mid, line_start, line_end in eparams:
        ratio = distance(edj, line_mid) / distance(line_start, line_end)
        max_ratio = max(ratio, max_ratio)
    return target_ratio - max_ratio


def fix_lens_distortion(img, dest_size, anchor_size, align, edges):
    target_ratio = _edge_to_anchor_ratio(dest_size, anchor_size)
    df = _get_distortion_factor(align, edges, target_ratio)
    print(f'target_ratio {target_ratio}, distortion factor {df}')
    return _naive_undistort(img, df)


def deskewer(src_image, dst_image, dark, use_edges=True, auto_dewarp=True, anchor_size=30):
    img = cv2.imread(src_image)
    cs = CimbarScanner(img, dark, 17)
    align = cs.scan()
    print(align.corners)

    if len(align.corners) < 4:
        print('didnt detect enough points! :(')
        return

    ''' given a 1024x1024 image and a 52px anchor size, corners should correspond to:
     (26, 26)
     (998, 26)
     (26, 998)
     (998, 998)
    '''
    # i.e. width is CELL_DIMENSIONS * CELL_SPACING
    top_left, top_right, bottom_left, bottom_right = align.corners
    # print(f'top left: {top_left}, top right: {top_right}, bottom right: {bottom_right}, bottom left: {bottom_left}')

    from cimbar.cimbar import TOTAL_SIZE
    size = TOTAL_SIZE

    input_pts = [top_left, top_right, bottom_right, bottom_left]
    output_pts = [
        (anchor_size, anchor_size), (size-anchor_size, anchor_size),
        (size-anchor_size, size-anchor_size), (anchor_size, size-anchor_size)
    ]
    if use_edges:
        ce = cs.scan_edges(align, anchor_size)
        print(f'edges are: {ce.edges}')
        mid = size // 2
        for p, outP in zip(ce.edges, [(mid, ED_DIST), (size-ED_DIST, mid), (mid, size-ED_DIST), (ED_DIST, mid)]):
            if p:
                input_pts.append(p)
                output_pts.append(outP)

        # if we have edges, we can attempt to dewarp
        if auto_dewarp:
            img = fix_lens_distortion(img, size, anchor_size, align, ce)

    out = correct_perspective(img, (size, size), input_pts, output_pts)
    cv2.imwrite(dst_image, out)
